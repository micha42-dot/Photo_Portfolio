<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Michael Förtsch | Portfolio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500&family=Outfit:wght@300;400;500;700&display=swap" rel="stylesheet">

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Manrope', 'sans-serif'],
                        display: ['Outfit', 'sans-serif'],
                    },
                    colors: {
                        black: '#0a0a0a',
                        gray: { 50: '#f9fafb', 100: '#f3f4f6', 900: '#111827' }
                    }
                }
            }
        }
    </script>
    <style>
        /* Basis-Konfiguration */
        :root {
            --gap: 12px;
        }

        .gallery-container {
            display: flex;
            flex-direction: column;
            gap: var(--gap);
            width: 100%;
            overflow: hidden; 
            padding-bottom: 80px;
        }

        .gallery-row {
            display: flex;
            flex-direction: row;
            /* CRITICAL FIX: Verhindert, dass Rundungsfehler das letzte Bild umbrechen */
            flex-wrap: nowrap; 
            justify-content: space-between;
            width: 100%;
            gap: var(--gap);
            opacity: 0;
            transform: translateY(20px);
            animation: fadeUp 0.8s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
        }

        @keyframes fadeUp {
            to { opacity: 1; transform: translateY(0); }
        }

        .img-item {
            position: relative;
            background-color: #f3f4f6;
            cursor: pointer;
            overflow: hidden;
            flex-shrink: 1; /* Erlaubt minimales Stauchen bei Sub-Pixel-Fehlern */
            flex-grow: 0;
        }

        .gallery-img {
            height: 100%;
            width: 100%;
            display: block;
            transition: transform 0.7s ease;
            object-fit: cover; 
        }

        .img-item:hover .gallery-img {
            transform: scale(1.03);
        }

        .dropdown-menu {
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: all 0.2s ease-in-out;
        }
        .group:hover .dropdown-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.4",
    "react/": "https://esm.sh/react@^19.2.4/",
    "@vitejs/plugin-react": "https://esm.sh/@vitejs/plugin-react@^5.1.3",
    "vite": "https://esm.sh/vite@^7.3.1"
  }
}
</script>
</head>
<body class="bg-white text-gray-900 flex flex-col min-h-screen">

    <!-- HEADER -->
    <header class="fixed top-0 w-full bg-white/95 backdrop-blur-md z-40 border-b border-gray-100 transition-all duration-300" id="main-header">
        <div class="max-w-[1800px] mx-auto px-6 h-12 flex items-center justify-between">
            
            <a href="#" onclick="app.filter('home')" class="font-display font-bold text-lg md:text-xl tracking-[0.15em] uppercase hover:opacity-60 transition-opacity">
                Michael Förtsch
            </a>

            <nav class="hidden md:flex items-center gap-8">
                <div class="relative group cursor-pointer py-4">
                    <span class="text-xs font-display font-medium tracking-[0.15em] uppercase text-gray-400 group-hover:text-black transition-colors flex items-center gap-1">
                        Kategorien
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </span>
                    <div class="dropdown-menu absolute left-0 top-full bg-white border border-gray-100 shadow-xl p-2 min-w-[200px] flex flex-col gap-1">
                        <div id="desktop-dropdown-items"></div>
                    </div>
                </div>
                <div class="h-4 w-[1px] bg-gray-300 mx-2"></div>
                <a href="info.html" class="text-xs font-display font-medium tracking-[0.15em] uppercase text-gray-400 hover:text-black transition-colors">
                    Info
                </a>
            </nav>

            <button class="md:hidden p-2 -mr-2 text-black" onclick="app.toggleMobileMenu()">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 6h16M4 12h16M4 18h16"></path></svg>
            </button>
        </div>
    </header>

    <!-- MOBILE MENU -->
    <div id="mobile-menu" class="fixed inset-0 bg-white z-50 transform translate-x-full transition-transform duration-300 flex flex-col p-8">
        <div class="flex justify-end mb-8">
            <button onclick="app.toggleMobileMenu()" class="p-2">
                <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <nav id="mobile-nav-items" class="flex flex-col gap-6 text-xl font-display font-light uppercase tracking-widest text-center">
            <!-- Items via JS -->
        </nav>
        <a href="info.html" class="mt-8 text-center text-xl font-display font-light uppercase tracking-widest text-gray-400">Info & Kontakt</a>
    </div>

    <!-- MAIN GALLERY -->
    <main class="flex-grow pt-24 px-4 md:px-8 w-full max-w-[1800px] mx-auto">
        
        <div id="no-data-warning" class="hidden w-full max-w-2xl mx-auto text-center py-12 px-6 border border-yellow-200 bg-yellow-50 rounded-lg">
            <h3 class="text-yellow-800 font-bold mb-2">Galerie wird geladen...</h3>
            <p class="text-yellow-700 text-sm mb-4">Falls hier dauerhaft keine Bilder erscheinen:</p>
            <div class="text-left bg-white p-4 rounded text-xs font-mono text-gray-600 border border-gray-200 overflow-x-auto">
                <p>1. Hast du Bilder in den Ordner <code>images/</code> hochgeladen?</p>
                <p>2. Warte 1-2 Minuten nach dem Hochladen, GitHub verarbeitet die Bilder gerade.</p>
                <p>3. Wenn du lokal testest, musst du die Datei <code>data.js</code> manuell bearbeiten.</p>
            </div>
        </div>

        <div id="gallery-container" class="gallery-container">
            <!-- Bilder werden hier eingefügt -->
        </div>
        
        <!-- Loading Sentinel -->
        <div id="loading-trigger" class="h-24 w-full flex items-center justify-center mt-4 opacity-0 transition-opacity">
            <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce mx-1"></div>
            <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce mx-1 delay-100"></div>
            <div class="w-2 h-2 bg-gray-400 rounded-full animate-bounce mx-1 delay-200"></div>
        </div>
        
    </main>

    <!-- FOOTER -->
    <footer class="border-t border-gray-100 bg-gray-50 py-16 text-center">
        <h3 class="font-display font-bold tracking-widest uppercase mb-4 text-lg">Journalismus</h3>
        <p class="text-gray-500 font-light mb-8 max-w-md mx-auto px-4">
            Technologie- und Wissenschaftsjournalismus.
        </p>
        <a href="https://michaelfoertsch.de" target="_blank" class="inline-block border border-black px-8 py-3 text-xs font-bold tracking-widest uppercase hover:bg-black hover:text-white transition-colors">
            Zur Website
        </a>
        <div class="mt-16 text-[10px] text-gray-400 font-display tracking-widest">
            &copy; <span id="year"></span> MICHAEL FÖRTSCH.
        </div>
    </footer>

    <!-- LIGHTBOX -->
    <div id="lightbox" class="fixed inset-0 z-50 bg-white/98 flex items-center justify-center opacity-0 pointer-events-none transition-opacity duration-300" onclick="if(event.target === this) app.closeLightbox()">
        <button onclick="app.closeLightbox()" class="absolute top-6 right-6 p-4 hover:opacity-50 transition-opacity z-50">
            <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M6 18L18 6M6 6l12 12"></path></svg>
        </button>
        
        <button onclick="app.prevImage()" class="absolute left-4 top-1/2 -translate-y-1/2 p-4 hover:opacity-50 transition-opacity hidden md:block">
            <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M15 19l-7-7 7-7"></path></svg>
        </button>
        
        <button onclick="app.nextImage()" class="absolute right-4 top-1/2 -translate-y-1/2 p-4 hover:opacity-50 transition-opacity hidden md:block">
            <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M9 5l7 7-7 7"></path></svg>
        </button>

        <img id="lightbox-img" class="max-w-[95vw] max-h-[90vh] object-contain shadow-2xl" src="" alt="">
        <div id="lightbox-caption" class="absolute bottom-6 left-0 right-0 text-center font-display text-xs tracking-widest uppercase text-gray-500"></div>
    </div>

    <!-- DATA -->
    <script src="data.js"></script>

    <!-- APP LOGIC -->
    <script>
        const app = {
            data: [],
            currentImages: [], 
            processedImages: [], 
            
            renderedCount: 0,
            batchSize: 10,
            lightboxIndex: 0,
            observer: null,
            currentCategory: 'home',
            isLoading: false,
            
            gap: 12, 
            idealHeight: 320, 

            init: function() {
                if(!window.portfolioData || window.portfolioData.length === 0) {
                    console.warn("data.js ist leer.");
                    document.getElementById('no-data-warning').classList.remove('hidden');
                    return;
                }
                
                this.data = window.portfolioData;
                document.getElementById('year').textContent = new Date().getFullYear();

                this.setupNavigation();
                this.setupObserver();
                this.updateIdealHeight();
                
                let resizeTimer;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimer);
                    resizeTimer = setTimeout(() => {
                        this.updateIdealHeight();
                        // Bei Resize rendern wir alles neu, damit die Zeilen passend brechen
                        this.reRender();
                    }, 200);
                });

                this.filter('home'); 
                
                document.addEventListener('keydown', (e) => {
                    if (document.getElementById('lightbox').classList.contains('opacity-0')) return;
                    if (e.key === 'Escape') this.closeLightbox();
                    if (e.key === 'ArrowRight') this.nextImage();
                    if (e.key === 'ArrowLeft') this.prevImage();
                });
            },

            updateIdealHeight: function() {
                // Je kleiner der Screen, desto kleiner die Zeilenhöhe, damit mehr Bilder pro Zeile passen
                if (window.innerWidth < 768) {
                    this.idealHeight = 180; 
                } else if (window.innerWidth < 1200) {
                    this.idealHeight = 260; 
                } else {
                    this.idealHeight = 350; 
                }
            },

            setupNavigation: function() {
                const dropContainer = document.getElementById('desktop-dropdown-items');
                const mobNav = document.getElementById('mobile-nav-items');

                this.data.forEach(cat => {
                    if(cat.id === 'general') return;
                    const dropBtn = document.createElement('button');
                    dropBtn.textContent = cat.label;
                    dropBtn.className = "text-left w-full px-4 py-2 text-xs font-display font-medium tracking-widest uppercase text-gray-500 hover:bg-gray-50 hover:text-black transition-colors";
                    dropBtn.onclick = () => this.filter(cat.id);
                    dropContainer.appendChild(dropBtn);
                    mobNav.appendChild(this.createMobileLink(cat.id, cat.label));
                });
            },

            createMobileLink: function(id, label) {
                const btn = document.createElement('button');
                btn.textContent = label;
                btn.onclick = () => { this.filter(id); this.toggleMobileMenu(); };
                return btn;
            },

            filter: async function(catId) {
                this.currentCategory = catId;
                this.renderedCount = 0;
                this.isLoading = false;
                this.processedImages = [];
                document.getElementById('gallery-container').innerHTML = ''; 
                
                window.scrollTo({top: 0, behavior: 'smooth'});

                if (catId === 'home') {
                    // --- HOME LOGIC: 7 REIHEN FÜLLEN ---
                    
                    // 1. Alle verfügbaren Bilder holen
                    let allImages = this.data.flatMap(cat => 
                        cat.images.map(src => ({ src: src, title: this.formatTitle(src) }))
                    );
                    
                    // 2. Mischen
                    for (let i = allImages.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [allImages[i], allImages[j]] = [allImages[j], allImages[i]];
                    }

                    // 3. Einen großen Batch vorladen (60 Bilder sollten locker für 7 Reihen reichen)
                    const candidateImages = allImages.slice(0, 60);
                    
                    // Loader anzeigen
                    document.getElementById('loading-trigger').classList.add('opacity-100');

                    // 4. Dimensionen laden
                    const loadedCandidates = await Promise.all(candidateImages.map(item => this.preloadImage(item)));
                    const validCandidates = loadedCandidates.filter(item => item !== null);
                    
                    // 5. Geometrie berechnen, aber Limit setzen
                    this.renderGeometry(validCandidates, false, 7); // Max 7 Reihen
                    
                    document.getElementById('loading-trigger').classList.remove('opacity-100');

                    // Auf der Home-Seite deaktivieren wir das Infinite Loading
                    if(this.observer) this.observer.disconnect();

                } else {
                    // --- NORMALE KATEGORIE: INFINITE SCROLL ---
                    const category = this.data.find(c => c.id === catId);
                    if(category) {
                        this.currentImages = category.images.map(src => ({ src: src, title: this.formatTitle(src) }));
                    } else {
                        this.currentImages = [];
                    }
                    // Observer reaktivieren falls deaktiviert
                    this.setupObserver();
                    this.loadMore();
                }
            },
            
            preloadImage: function(imgObj) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.src = imgObj.src;
                    img.onload = () => {
                        resolve({
                            ...imgObj,
                            width: img.naturalWidth,
                            height: img.naturalHeight,
                            ratio: img.naturalWidth / img.naturalHeight
                        });
                    };
                    img.onerror = () => resolve(null);
                });
            },

            reRender: function() {
                if(this.processedImages.length === 0) return;
                document.getElementById('gallery-container').innerHTML = '';
                // Beim Resize zeichnen wir alle bisher geladenen Bilder neu
                // Home: Behält das 7-Reihen Limit implizit durch processedImages (wir laden nicht nach)
                this.renderGeometry(this.processedImages, true); 
            },

            loadMore: async function() {
                if (this.isLoading || this.currentCategory === 'home') return;

                const trigger = document.getElementById('loading-trigger');
                
                if (this.renderedCount >= this.currentImages.length) {
                    trigger.classList.remove('opacity-100');
                    return;
                }

                this.isLoading = true;
                trigger.classList.add('opacity-100');

                const nextBatchRaw = this.currentImages.slice(this.renderedCount, this.renderedCount + this.batchSize);
                const loadedBatch = await Promise.all(nextBatchRaw.map(item => this.preloadImage(item)));
                const validBatch = loadedBatch.filter(item => item !== null);

                // Hier fügen wir sie hinzu und rendern
                this.renderGeometry(validBatch, false);

                this.renderedCount += nextBatchRaw.length;
                this.isLoading = false;
                trigger.classList.remove('opacity-100');
            },

            renderGeometry: function(imagesToRender, isRedraw = false, maxRows = 0) {
                const container = document.getElementById('gallery-container');
                // Puffer für Scrollbar abziehen falls nötig, floor für Sicherheit
                const containerWidth = Math.floor(container.getBoundingClientRect().width); 
                
                let rowBuffer = [];
                let rowAspectRatioSum = 0;
                let rowsCreated = 0;

                // Wenn wir neu zeichnen, nutzen wir alle Bilder. Wenn nicht, fügen wir die neuen hinzu.
                let imagesSource = isRedraw ? imagesToRender : imagesToRender;

                // Nur wenn NICHT Redraw, updaten wir das globale Array
                if (!isRedraw) {
                     // Aufpassen: bei Home haben wir schon gefiltert, bei LoadMore kommt ein Batch
                     // Wir fügen sie einfach hinzu, wenn sie nicht schon da sind (einfacher Check über globalIndex logic wäre besser, aber hier reicht push)
                     // Aber wir müssen aufpassen, dass wir bei Home "processedImages" richtig setzen
                }
                
                // Für die Schleife brauchen wir einen Start-Index für die Lightbox
                let startIndex = this.processedImages.length;
                if(isRedraw) startIndex = 0;

                // Temporäres Array für das, was wir jetzt rendern WÜRDEN
                let renderedInThisCall = [];

                for (let i = 0; i < imagesSource.length; i++) {
                    // Check Row Limit (nur für Home relevant)
                    if (maxRows > 0 && rowsCreated >= maxRows) break;

                    const img = imagesSource[i];
                    const globalIndex = startIndex + i;
                    
                    // Objekt für processedImages vorbereiten (falls noch nicht drin)
                    const imgWithIndex = { ...img, globalIndex };
                    renderedInThisCall.push(imgWithIndex);

                    rowBuffer.push(imgWithIndex);
                    rowAspectRatioSum += img.ratio;

                    const currentWidth = (rowAspectRatioSum * this.idealHeight) + ((rowBuffer.length - 1) * this.gap);

                    if (currentWidth >= containerWidth) {
                        this.flushRow(container, rowBuffer, rowAspectRatioSum, containerWidth);
                        rowBuffer = [];
                        rowAspectRatioSum = 0;
                        rowsCreated++;
                    }
                }

                // WICHTIG: Wenn wir Home sind und maxRows haben, müssen wir processedImages auf das begrenzen, was wirklich gerendert wurde
                if (!isRedraw) {
                    // Wir haben abgebrochen oder sind fertig. 
                    // Die Bilder im rowBuffer (Orphans) verwerfen wir bei 'Home', um unfertige Zeilen zu vermeiden?
                    // Nein, User sagte "7 Reihen". Wenn die 7. Reihe halb voll ist, ist das okay?
                    // Besser: Wir rendern Orphans nur wenn wir nicht im "Strict Mode" (Home) sind oder wenn es wirklich die allerletzten Bilder sind.
                    
                    if (maxRows > 0) {
                         // Home Mode: Wir speichern nur die Bilder, die es in die 7 Reihen geschafft haben
                         // Die Bilder im rowBuffer sind "übrig". Wenn wir genau 7 Reihen wollten, sind wir hier fertig.
                         // Wenn rowsCreated < 7, müssen wir die Orphan Row rendern.
                         if (rowBuffer.length > 0 && rowsCreated < maxRows) {
                             this.flushRow(container, rowBuffer, rowAspectRatioSum, containerWidth, true);
                             rowsCreated++;
                         }
                         
                         // Wir fügen ALLE gerenderten Bilder zu processedImages hinzu (fürs Resize später)
                         // Da wir renderedInThisCall haben, müssen wir filtern, was wirklich geflusht wurde?
                         // Vereinfachung: Wir nehmen renderedInThisCall. 
                         // Aber wir müssen die Bilder, die im letzten Buffer waren aber NICHT geflusht wurden (weil rowsCreated >= maxRows limit hit), entfernen.
                         // Das ist komplex. Einfacher: Wir nutzen den DOM State oder bauen processedImages sauber auf.
                         
                         // Fix: Wir fügen einfach alles hinzu, was wir verarbeitet haben.
                         this.processedImages = [...this.processedImages, ...renderedInThisCall];
                         
                         // Aber wir müssen die überschüssigen aus dem Buffer entfernen, falls wir abgebrochen haben?
                         // Wenn die Schleife bei break rausgeht, ist rowBuffer nicht leer? Nein, break passiert am Anfang.
                         // Wenn wir am Ende sind und rowBuffer voll ist -> Orphan flush.
                    } else {
                        // Normaler Modus (Kategorie)
                        if (rowBuffer.length > 0) {
                             this.flushRow(container, rowBuffer, rowAspectRatioSum, containerWidth, true);
                        }
                        this.processedImages = [...this.processedImages, ...renderedInThisCall];
                    }
                } else {
                    // Beim Redraw (Resize) müssen wir Orphans immer rendern
                    if (rowBuffer.length > 0) {
                        this.flushRow(container, rowBuffer, rowAspectRatioSum, containerWidth, true);
                    }
                }
            },

            flushRow: function(container, rowImages, totalRatio, containerWidth, isOrphan = false) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'gallery-row';
                
                const totalGapWidth = (rowImages.length - 1) * this.gap;
                const availableWidthForImages = containerWidth - totalGapWidth;

                let rowHeight = availableWidthForImages / totalRatio;

                if (isOrphan) {
                    // Bei Orphan Row (letzte Zeile) begrenzen wir die Höhe auf IdealHeight
                    // Damit das Bild nicht riesig wird
                    rowHeight = this.idealHeight;
                    // Wir müssen justify-content anpassen, da space-between sonst Bilder nach außen drückt
                    rowDiv.style.justifyContent = 'flex-start';
                }

                rowDiv.style.height = Math.floor(rowHeight) + 'px';

                rowImages.forEach(img => {
                    const div = document.createElement('div');
                    div.className = 'img-item group';
                    div.onclick = () => this.openLightbox(img.globalIndex);
                    
                    const imgWidth = rowHeight * img.ratio;
                    
                    div.style.width = imgWidth + 'px'; // Float ist ok, Browser verrechnet das
                    div.style.height = Math.floor(rowHeight) + 'px'; 

                    const imageEl = new Image();
                    imageEl.src = img.src;
                    imageEl.alt = img.title;
                    imageEl.className = 'gallery-img';
                    imageEl.loading = 'lazy';
                    
                    div.appendChild(imageEl);

                    const overlay = document.createElement('div');
                    overlay.className = "absolute inset-0 bg-black/0 group-hover:bg-black/10 transition-colors duration-300 pointer-events-none";
                    div.appendChild(overlay);

                    rowDiv.appendChild(div);
                });

                container.appendChild(rowDiv);
            },

            setupObserver: function() {
                if(this.observer) this.observer.disconnect();
                const options = { root: null, rootMargin: '400px', threshold: 0.1 };
                this.observer = new IntersectionObserver((entries) => {
                    if(entries[0].isIntersecting) {
                        this.loadMore();
                    }
                }, options);
                this.observer.observe(document.getElementById('loading-trigger'));
            },

            openLightbox: function(index) {
                if (index < 0 || index >= this.processedImages.length) return;
                this.lightboxIndex = index;
                this.updateLightbox();
                const lb = document.getElementById('lightbox');
                lb.classList.remove('opacity-0', 'pointer-events-none');
                document.body.style.overflow = 'hidden';
            },

            closeLightbox: function() {
                const lb = document.getElementById('lightbox');
                lb.classList.add('opacity-0', 'pointer-events-none');
                document.body.style.overflow = '';
                setTimeout(() => { document.getElementById('lightbox-img').src = ''; }, 300);
            },

            updateLightbox: function() {
                const data = this.processedImages[this.lightboxIndex];
                if(!data) return;
                
                const img = document.getElementById('lightbox-img');
                const caption = document.getElementById('lightbox-caption');
                const safeSrc = data.src.split('/').map(s => encodeURIComponent(s)).join('/');
                const tempImg = new Image();
                tempImg.onload = () => { img.src = tempImg.src; };
                tempImg.src = safeSrc;
                caption.textContent = data.title;
            },

            nextImage: function() {
                this.lightboxIndex = (this.lightboxIndex + 1) % this.processedImages.length;
                this.updateLightbox();
            },

            prevImage: function() {
                this.lightboxIndex = (this.lightboxIndex - 1 + this.processedImages.length) % this.processedImages.length;
                this.updateLightbox();
            },

            toggleMobileMenu: function() {
                const menu = document.getElementById('mobile-menu');
                menu.classList.toggle('translate-x-full');
            },

            formatTitle: function(pathStr) {
                const filename = pathStr.split('/').pop().split('.')[0];
                return filename.replace(/[\(\)\d_-]/g, ' ').trim();
            }
        };

        window.addEventListener('DOMContentLoaded', () => app.init());
    </script>
</body>
</html>